"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaterialPbrMetallicRoughness = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
var flatbuffers = require("flatbuffers");
var texture_info_js_1 = require("../fla2/texture-info.js");
/**
 * Material PBR Metallic Roughness
 * "description": "A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology."
 */
var MaterialPbrMetallicRoughness = /** @class */ (function () {
    function MaterialPbrMetallicRoughness() {
        this.bb = null;
        this.bb_pos = 0;
    }
    MaterialPbrMetallicRoughness.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    MaterialPbrMetallicRoughness.getRootAsMaterialPbrMetallicRoughness = function (bb, obj) {
        return (obj || new MaterialPbrMetallicRoughness()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    MaterialPbrMetallicRoughness.getSizePrefixedRootAsMaterialPbrMetallicRoughness = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new MaterialPbrMetallicRoughness()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * "description": "The material's base color factor."
     * "gltf_detailedDescription": "The RGBA components of the base color of the material. The fourth component (A) is the alpha coverage of the material. The `alphaMode` property specifies how alpha is interpreted. These values are linear. If a baseColorTexture is specified, this value is multiplied with the texel values."
     * "minItems": 4
     * "maxItems": 4
     * "default": [ 1.0, 1.0, 1.0, 1.0 ]
     */
    MaterialPbrMetallicRoughness.prototype.baseColorFactor = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    };
    MaterialPbrMetallicRoughness.prototype.baseColorFactorLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    MaterialPbrMetallicRoughness.prototype.baseColorFactorArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * "description": "The base color texture."
     * "gltf_detailedDescription": "The base color texture. This texture contains RGB(A) components in sRGB color space. The first three components (RGB) specify the base color of the material. If the fourth component (A) is present, it represents the alpha coverage of the material. Otherwise, an alpha of 1.0 is assumed. The `alphaMode` property specifies how alpha is interpreted. The stored texels must not be premultiplied."
     */
    MaterialPbrMetallicRoughness.prototype.baseColorTexture = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new texture_info_js_1.TextureInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    /**
     * "description": "The metalness of the material."
     * "gltf_detailedDescription": "The metalness of the material. A value of 1.0 means the material is a metal. A value of 0.0 means the material is a dielectric. Values in between are for blending between metals and dielectrics such as dirty metallic surfaces. This value is linear. If a metallicRoughnessTexture is specified, this value is multiplied with the metallic texel values."
     */
    MaterialPbrMetallicRoughness.prototype.metallicFactor = function () {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 1.0;
    };
    /**
     * "description": "The roughness of the material."
     * "gltf_detailedDescription": "The roughness of the material. A value of 1.0 means the material is completely rough. A value of 0.0 means the material is completely smooth. This value is linear. If a metallicRoughnessTexture is specified, this value is multiplied with the roughness texel values."
     * "minimum": 0.0
     * "maximum": 1.0
     * "default": 1.0
     */
    MaterialPbrMetallicRoughness.prototype.roughnessFactor = function () {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 1.0;
    };
    /**
     * "description": "The metallic-roughness texture."
     * "gltf_detailedDescription": "The metallic-roughness texture. The metalness values are sampled from the B channel. The roughness values are sampled from the G channel. These values are linear. If other channels are present (R or A), they are ignored for metallic-roughness calculations."
     */
    MaterialPbrMetallicRoughness.prototype.metallicRoughnessTexture = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new texture_info_js_1.TextureInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    /**
     * Dictionary object with extension-specific objects.
     */
    MaterialPbrMetallicRoughness.prototype.extensions = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    };
    MaterialPbrMetallicRoughness.prototype.extensionsLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    MaterialPbrMetallicRoughness.prototype.extensionsArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * Application-specific data.
     */
    MaterialPbrMetallicRoughness.prototype.extras = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    };
    MaterialPbrMetallicRoughness.prototype.extrasLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    MaterialPbrMetallicRoughness.prototype.extrasArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    MaterialPbrMetallicRoughness.startMaterialPbrMetallicRoughness = function (builder) {
        builder.startObject(7);
    };
    MaterialPbrMetallicRoughness.addBaseColorFactor = function (builder, baseColorFactorOffset) {
        builder.addFieldOffset(0, baseColorFactorOffset, 0);
    };
    MaterialPbrMetallicRoughness.createBaseColorFactorVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addFloat32(data[i]);
        }
        return builder.endVector();
    };
    MaterialPbrMetallicRoughness.startBaseColorFactorVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    MaterialPbrMetallicRoughness.addBaseColorTexture = function (builder, baseColorTextureOffset) {
        builder.addFieldOffset(1, baseColorTextureOffset, 0);
    };
    MaterialPbrMetallicRoughness.addMetallicFactor = function (builder, metallicFactor) {
        builder.addFieldFloat32(2, metallicFactor, 1.0);
    };
    MaterialPbrMetallicRoughness.addRoughnessFactor = function (builder, roughnessFactor) {
        builder.addFieldFloat32(3, roughnessFactor, 1.0);
    };
    MaterialPbrMetallicRoughness.addMetallicRoughnessTexture = function (builder, metallicRoughnessTextureOffset) {
        builder.addFieldOffset(4, metallicRoughnessTextureOffset, 0);
    };
    MaterialPbrMetallicRoughness.addExtensions = function (builder, extensionsOffset) {
        builder.addFieldOffset(5, extensionsOffset, 0);
    };
    MaterialPbrMetallicRoughness.createExtensionsVector = function (builder, data) {
        builder.startVector(1, data.length, 1);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    };
    MaterialPbrMetallicRoughness.startExtensionsVector = function (builder, numElems) {
        builder.startVector(1, numElems, 1);
    };
    MaterialPbrMetallicRoughness.addExtras = function (builder, extrasOffset) {
        builder.addFieldOffset(6, extrasOffset, 0);
    };
    MaterialPbrMetallicRoughness.createExtrasVector = function (builder, data) {
        builder.startVector(1, data.length, 1);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    };
    MaterialPbrMetallicRoughness.startExtrasVector = function (builder, numElems) {
        builder.startVector(1, numElems, 1);
    };
    MaterialPbrMetallicRoughness.endMaterialPbrMetallicRoughness = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    return MaterialPbrMetallicRoughness;
}());
exports.MaterialPbrMetallicRoughness = MaterialPbrMetallicRoughness;
