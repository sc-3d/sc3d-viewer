"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Material = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
var flatbuffers = require("flatbuffers");
var material_alpha_mode_js_1 = require("../fla2/material-alpha-mode.js");
var material_normal_texture_info_js_1 = require("../fla2/material-normal-texture-info.js");
var material_occlusion_texture_info_js_1 = require("../fla2/material-occlusion-texture-info.js");
var material_pbr_metallic_roughness_js_1 = require("../fla2/material-pbr-metallic-roughness.js");
var texture_info_js_1 = require("../fla2/texture-info.js");
/**
 * Material
 * "description": "The material appearance of a primitive."
 */
var Material = /** @class */ (function () {
    function Material() {
        this.bb = null;
        this.bb_pos = 0;
    }
    Material.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    Material.getRootAsMaterial = function (bb, obj) {
        return (obj || new Material()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    Material.getSizePrefixedRootAsMaterial = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Material()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * "description": "A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology. When not specified, all the default values of `pbrMetallicRoughness` apply."
     */
    Material.prototype.pbrMetallicRoughness = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new material_pbr_metallic_roughness_js_1.MaterialPbrMetallicRoughness()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    /**
     * "description": "The normal map texture."
     * "gltf_detailedDescription": "A tangent space normal map. The texture contains RGB components in linear space. Each texel represents the XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X [-1 to 1]. Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer. In GLSL, this vector would be unpacked like so: `float3 normalVector = tex2D(<sampled normal map texture value>, texCoord) * 2 - 1`."
     */
    Material.prototype.normalTexture = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new material_normal_texture_info_js_1.MaterialNormalTextureInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    /**
     * "description": "The occlusion map texture."
     * "gltf_detailedDescription": "The occlusion map texture. The occlusion values are sampled from the R channel. Higher values indicate areas that should receive full indirect lighting and lower values indicate no indirect lighting. These values are linear. If other channels are present (GBA), they are ignored for occlusion calculations."
     */
    Material.prototype.occlusionTexture = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new material_occlusion_texture_info_js_1.MaterialOcclusionTextureInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    /**
     * "description": "The emissive map texture."
     * "gltf_detailedDescription": "The emissive map controls the color and intensity of the light being emitted by the material. This texture contains RGB components in sRGB color space. If a fourth component (A) is present, it is ignored."
     */
    Material.prototype.emissiveTexture = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new texture_info_js_1.TextureInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    /**
     * "description": "The emissive color of the material."
     * "gltf_detailedDescription": "The RGB components of the emissive color of the material. These values are linear. If an emissiveTexture is specified, this value is multiplied with the texel values."
     * "minItems": 3,
     * "maxItems": 3,
     * "default": [ 0.0, 0.0, 0.0 ],
     */
    Material.prototype.emissiveFactor = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    };
    Material.prototype.emissiveFactorLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Material.prototype.emissiveFactorArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * Dictionary object with extension-specific objects.
     */
    Material.prototype.extensions = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    };
    Material.prototype.extensionsLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Material.prototype.extensionsArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * Application-specific data.
     */
    Material.prototype.extras = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    };
    Material.prototype.extrasLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Material.prototype.extrasArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * "description": "Specifies whether the material is double sided."
     * "gltf_detailedDescription": "Specifies whether the material is double sided. When this value is false, back-face culling is enabled. When this value is true, back-face culling is disabled and double sided lighting is enabled. The back-face must have its normals reversed before the lighting equation is evaluated."
     */
    Material.prototype.doubleSided = function () {
        var offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    };
    Material.prototype.name = function (optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    /**
     * "description": "The alpha cutoff value of the material."
     * "gltf_detailedDescription": "Specifies the cutoff threshold when in `MASK` mode. If the alpha value is greater than or equal to this value then it is rendered as fully opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire material as fully transparent. This value is ignored for other modes."
     */
    Material.prototype.alphaCutoff = function () {
        var offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.5;
    };
    /**
     * "description": "The alpha rendering mode of the material."
     * "gltf_detailedDescription": "The material's alpha rendering mode enumeration specifying the interpretation of the alpha value of the main factor and texture."
     */
    Material.prototype.alphaMode = function () {
        var offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : material_alpha_mode_js_1.MaterialAlphaMode.OPAQUE;
    };
    Material.startMaterial = function (builder) {
        builder.startObject(11);
    };
    Material.addPbrMetallicRoughness = function (builder, pbrMetallicRoughnessOffset) {
        builder.addFieldOffset(0, pbrMetallicRoughnessOffset, 0);
    };
    Material.addNormalTexture = function (builder, normalTextureOffset) {
        builder.addFieldOffset(1, normalTextureOffset, 0);
    };
    Material.addOcclusionTexture = function (builder, occlusionTextureOffset) {
        builder.addFieldOffset(2, occlusionTextureOffset, 0);
    };
    Material.addEmissiveTexture = function (builder, emissiveTextureOffset) {
        builder.addFieldOffset(3, emissiveTextureOffset, 0);
    };
    Material.addEmissiveFactor = function (builder, emissiveFactorOffset) {
        builder.addFieldOffset(4, emissiveFactorOffset, 0);
    };
    Material.createEmissiveFactorVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addFloat32(data[i]);
        }
        return builder.endVector();
    };
    Material.startEmissiveFactorVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    Material.addExtensions = function (builder, extensionsOffset) {
        builder.addFieldOffset(5, extensionsOffset, 0);
    };
    Material.createExtensionsVector = function (builder, data) {
        builder.startVector(1, data.length, 1);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    };
    Material.startExtensionsVector = function (builder, numElems) {
        builder.startVector(1, numElems, 1);
    };
    Material.addExtras = function (builder, extrasOffset) {
        builder.addFieldOffset(6, extrasOffset, 0);
    };
    Material.createExtrasVector = function (builder, data) {
        builder.startVector(1, data.length, 1);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    };
    Material.startExtrasVector = function (builder, numElems) {
        builder.startVector(1, numElems, 1);
    };
    Material.addDoubleSided = function (builder, doubleSided) {
        builder.addFieldInt8(7, +doubleSided, +false);
    };
    Material.addName = function (builder, nameOffset) {
        builder.addFieldOffset(8, nameOffset, 0);
    };
    Material.addAlphaCutoff = function (builder, alphaCutoff) {
        builder.addFieldFloat32(9, alphaCutoff, 0.5);
    };
    Material.addAlphaMode = function (builder, alphaMode) {
        builder.addFieldInt16(10, alphaMode, material_alpha_mode_js_1.MaterialAlphaMode.OPAQUE);
    };
    Material.endMaterial = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    return Material;
}());
exports.Material = Material;
