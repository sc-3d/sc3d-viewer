"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
var flatbuffers = require("flatbuffers");
/**
 *----------------------------------------------------------------------------
 * Node
 * "description": "A node in the node hierarchy.  When the node contains `skin`, all `mesh.primitives` must contain `JOINTS_0` and `WEIGHTS_0` attributes.  A node can have either a `matrix` or any combination of `translation`/`rotation`/`scale` (TRS) properties. TRS properties are converted to matrices and postmultiplied in the `T * R * S` order to compose the transformation matrix; first the scale is applied to the vertices, then the rotation, and then the translation. If none are provided, the transform is the identity. When a node is targeted for animation (referenced by an animation.channel.target), only TRS properties may be present; `matrix` will not be present."
 */
var Node = /** @class */ (function () {
    function Node() {
        this.bb = null;
        this.bb_pos = 0;
    }
    Node.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    Node.getRootAsNode = function (bb, obj) {
        return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    Node.getSizePrefixedRootAsNode = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * "description": "The index of the camera referenced by this node."
     */
    Node.prototype.camera = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : -1;
    };
    /**
     * "description": "The indices of this node's children."
     */
    Node.prototype.children = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    };
    Node.prototype.childrenLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Node.prototype.childrenArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * Dictionary object with extension-specific objects.
     */
    Node.prototype.extensions = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    };
    Node.prototype.extensionsLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Node.prototype.extensionsArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * Application-specific data.
     */
    Node.prototype.extras = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    };
    Node.prototype.extrasLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Node.prototype.extrasArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * "description": "The weights of the instantiated Morph Target. Number of elements must match number of Morph Targets of used mesh."
     * "minItems": 1
     */
    Node.prototype.weights = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    };
    Node.prototype.weightsLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Node.prototype.weightsArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * "description": "The index of the mesh in this node."
     */
    Node.prototype.mesh = function () {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : -1;
    };
    Node.prototype.name = function (optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    /**
     * "description": "The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar."
     * "minimum": -1.0
     * "maximum": 1.0
     * "minItems": 4
     * "maxItems": 4
     * "default": [ 0.0, 0.0, 0.0, 1.0 ]
     */
    Node.prototype.rotation = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    };
    Node.prototype.rotationLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Node.prototype.rotationArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * "description": "The node's non-uniform scale."
     * "minItems": 3
     * "maxItems": 3
     * "default": [ 1.0, 1.0, 1.0 ]
     */
    Node.prototype.scale = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    };
    Node.prototype.scaleLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Node.prototype.scaleArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * "description": "The index of the skin referenced by this node."
     */
    Node.prototype.skin = function () {
        var offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : -1;
    };
    /**
     * "description": "The node's translation."
     * "minItems": 3
     * "maxItems": 3
     * "default": [ 0.0, 0.0, 0.0 ]
     */
    Node.prototype.translation = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    };
    Node.prototype.translationLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Node.prototype.translationArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * "description": "A floating-point 4x4 transformation matrix stored in column-major order."
     * "gltf_detailedDescription": "A floating-point 4x4 transformation matrix stored in column-major order."
     * "gltf_webgl": "`uniformMatrix4fv()` with the transpose parameter equal to false"
     * "minItems": 16
     * "maxItems": 16
     * "default": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
     */
    Node.prototype.matrix = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    };
    Node.prototype.matrixLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    Node.prototype.matrixArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    Node.startNode = function (builder) {
        builder.startObject(12);
    };
    Node.addCamera = function (builder, camera) {
        builder.addFieldInt32(0, camera, -1);
    };
    Node.addChildren = function (builder, childrenOffset) {
        builder.addFieldOffset(1, childrenOffset, 0);
    };
    Node.createChildrenVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    };
    Node.startChildrenVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    Node.addExtensions = function (builder, extensionsOffset) {
        builder.addFieldOffset(2, extensionsOffset, 0);
    };
    Node.createExtensionsVector = function (builder, data) {
        builder.startVector(1, data.length, 1);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    };
    Node.startExtensionsVector = function (builder, numElems) {
        builder.startVector(1, numElems, 1);
    };
    Node.addExtras = function (builder, extrasOffset) {
        builder.addFieldOffset(3, extrasOffset, 0);
    };
    Node.createExtrasVector = function (builder, data) {
        builder.startVector(1, data.length, 1);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    };
    Node.startExtrasVector = function (builder, numElems) {
        builder.startVector(1, numElems, 1);
    };
    Node.addWeights = function (builder, weightsOffset) {
        builder.addFieldOffset(4, weightsOffset, 0);
    };
    Node.createWeightsVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addFloat32(data[i]);
        }
        return builder.endVector();
    };
    Node.startWeightsVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    Node.addMesh = function (builder, mesh) {
        builder.addFieldInt32(5, mesh, -1);
    };
    Node.addName = function (builder, nameOffset) {
        builder.addFieldOffset(6, nameOffset, 0);
    };
    Node.addRotation = function (builder, rotationOffset) {
        builder.addFieldOffset(7, rotationOffset, 0);
    };
    Node.createRotationVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addFloat32(data[i]);
        }
        return builder.endVector();
    };
    Node.startRotationVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    Node.addScale = function (builder, scaleOffset) {
        builder.addFieldOffset(8, scaleOffset, 0);
    };
    Node.createScaleVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addFloat32(data[i]);
        }
        return builder.endVector();
    };
    Node.startScaleVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    Node.addSkin = function (builder, skin) {
        builder.addFieldInt32(9, skin, -1);
    };
    Node.addTranslation = function (builder, translationOffset) {
        builder.addFieldOffset(10, translationOffset, 0);
    };
    Node.createTranslationVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addFloat32(data[i]);
        }
        return builder.endVector();
    };
    Node.startTranslationVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    Node.addMatrix = function (builder, matrixOffset) {
        builder.addFieldOffset(11, matrixOffset, 0);
    };
    Node.createMatrixVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addFloat32(data[i]);
        }
        return builder.endVector();
    };
    Node.startMatrixVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    Node.endNode = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Node.createNode = function (builder, camera, childrenOffset, extensionsOffset, extrasOffset, weightsOffset, mesh, nameOffset, rotationOffset, scaleOffset, skin, translationOffset, matrixOffset) {
        Node.startNode(builder);
        Node.addCamera(builder, camera);
        Node.addChildren(builder, childrenOffset);
        Node.addExtensions(builder, extensionsOffset);
        Node.addExtras(builder, extrasOffset);
        Node.addWeights(builder, weightsOffset);
        Node.addMesh(builder, mesh);
        Node.addName(builder, nameOffset);
        Node.addRotation(builder, rotationOffset);
        Node.addScale(builder, scaleOffset);
        Node.addSkin(builder, skin);
        Node.addTranslation(builder, translationOffset);
        Node.addMatrix(builder, matrixOffset);
        return Node.endNode(builder);
    };
    return Node;
}());
exports.Node = Node;
